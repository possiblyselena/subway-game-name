/*@license Copyright 2015-2022 Ably Real-time Ltd (ably.com)

Ably JavaScript Library v2.14.0
https://github.com/ably/ably-js

Released under the Apache Licence v2.0*/(function (g, f) {
    if ("object" == typeof exports && "object" == typeof module) {
      module.exports = f();
    } else if ("function" == typeof define && define.amd) {
      define([], f);
    } else if ("object" == typeof exports) {
      exports["AblyObjectsPlugin"] = f();
    } else {
      g["AblyObjectsPlugin"] = f();
    }
  }(this, () => {
var exports = {};
var module = { exports };
"use strict";var A=Object.defineProperty,H=Object.defineProperties,Q=Object.getOwnPropertyDescriptor,X=Object.getOwnPropertyDescriptors,ee=Object.getOwnPropertyNames,w=Object.getOwnPropertySymbols;var $=Object.prototype.hasOwnProperty,z=Object.prototype.propertyIsEnumerable;var k=(a,t)=>{if(t=Symbol[a])return t;throw Error("Symbol."+a+" is not defined")};var W=(a,t,e)=>t in a?A(a,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):a[t]=e,O=(a,t)=>{for(var e in t||(t={}))$.call(t,e)&&W(a,e,t[e]);if(w)for(var e of w(t))z.call(t,e)&&W(a,e,t[e]);return a},_=(a,t)=>H(a,X(t));var K=(a,t)=>{var e={};for(var i in a)$.call(a,i)&&t.indexOf(i)<0&&(e[i]=a[i]);if(a!=null&&w)for(var i of w(a))t.indexOf(i)<0&&z.call(a,i)&&(e[i]=a[i]);return e};var te=(a,t)=>{for(var e in t)A(a,e,{get:t[e],enumerable:!0})},ie=(a,t,e,i)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of ee(t))!$.call(a,n)&&n!==e&&A(a,n,{get:()=>t[n],enumerable:!(i=Q(t,n))||i.enumerable});return a};var ne=a=>ie(A({},"__esModule",{value:!0}),a);var ae=function(a,t){this[0]=a,this[1]=t};var P=a=>{var t=a[k("asyncIterator")],e=!1,i,n={};return t==null?(t=a[k("iterator")](),i=s=>n[s]=o=>t[s](o)):(t=t.call(a),i=s=>n[s]=o=>{if(e){if(e=!1,s==="throw")throw o;return o}return e=!0,{done:!1,value:new ae(new Promise(r=>{var c=t[s](o);if(!(c instanceof Object))throw TypeError("Object expected");r(c)}),1)}}),n[k("iterator")]=()=>n,i("next"),"throw"in t?i("throw"):n.throw=s=>{throw s},"return"in t&&i("return"),n};var re={};te(re,{ObjectMessage:()=>b,Objects:()=>C,WireObjectMessage:()=>y,default:()=>oe});module.exports=ne(re);function F(a,t,e,i){var s,o,r,c,p,d,l,h,g,m,L,D;let n=Object.assign(new y(t,e),G(a));return(o=(s=a.object)==null?void 0:s.map)!=null&&o.entries&&(n.object.map.entries=B(a.object.map.entries,i)),(p=(c=(r=a.object)==null?void 0:r.createOp)==null?void 0:c.map)!=null&&p.entries&&(n.object.createOp.map.entries=B(a.object.createOp.map.entries,i)),(h=(l=(d=a.object)==null?void 0:d.createOp)==null?void 0:l.mapOp)!=null&&h.data&&(n.object.createOp.mapOp.data=V(a.object.createOp.mapOp.data,i)),(m=(g=a.operation)==null?void 0:g.map)!=null&&m.entries&&(n.operation.map.entries=B(a.operation.map.entries,i)),(D=(L=a.operation)==null?void 0:L.mapOp)!=null&&D.data&&(n.operation.mapOp.data=V(a.operation.mapOp.data,i)),n}function B(a,t){return Object.entries(a).reduce((e,i)=>{let[n,s]=i,o=s.data?V(s.data,t):void 0;return e[n]=_(O({},s),{data:o}),e},{})}function V(a,t){return t(a)}function x(a,t){let i=b.fromValues({operation:a},t.Utils,t.MessageEncoding).encode(t),{operation:n}=i.encodeForWire(t.Utils.Format.json);return JSON.stringify(n)}function J(a,t){let e="["+t;for(let i in a)a[i]===void 0||i==="_utils"||i==="_messageEncoding"||(i==="operation"||i==="object"||i==="extras"?e+=`; ${i}=${JSON.stringify(a[i])}`:e+=`; ${i}=${a[i]}`);return e+="]",e}function G(a){let t={id:a.id,clientId:a.clientId,connectionId:a.connectionId,timestamp:a.timestamp,serial:a.serial,serialTimestamp:a.serialTimestamp,siteCode:a.siteCode};return a.operation&&(t.operation=JSON.parse(JSON.stringify(a.operation))),a.object&&(t.object=JSON.parse(JSON.stringify(a.object))),a.extras&&(t.extras=JSON.parse(JSON.stringify(a.extras))),t}var b=class a{constructor(t,e){this._utils=t;this._messageEncoding=e}static fromValues(t,e,i){return Object.assign(new a(e,i),t)}static fromValuesArray(t,e,i){return t.map(n=>a.fromValues(n,e,i))}encode(t){let e=i=>{let n={objectId:i.objectId};return t.Platform.BufferUtils.isBuffer(i.value)?n.bytes=i.value:typeof i.value=="string"?n.string=i.value:typeof i.value=="boolean"?n.boolean=i.value:typeof i.value=="number"?n.number=i.value:typeof i.value=="object"&&i.value!==null&&(n.json=JSON.stringify(i.value)),n};return F(this,this._utils,this._messageEncoding,e)}toString(){return J(this,"ObjectMessage")}},y=class a{constructor(t,e){this._utils=t;this._messageEncoding=e}static fromValues(t,e,i){return Object.assign(new a(e,i),t)}static fromValuesArray(t,e,i){return t.map(n=>a.fromValues(n,e,i))}encodeForWire(t){let e=i=>{if(i.bytes!=null){let n=this._messageEncoding.encodeDataForWire(i.bytes,null,t);return _(O({},i),{bytes:n.data})}return O({},i)};return F(this,this._utils,this._messageEncoding,e)}decode(t,e){var n,s,o,r,c,p,d,l,h,g,m,L;let i=Object.assign(new b(this._utils,this._messageEncoding),G(this));try{(s=(n=this.object)==null?void 0:n.map)!=null&&s.entries&&(i.object.map.entries=this._decodeMapEntries(this.object.map.entries,t,e)),(c=(r=(o=this.object)==null?void 0:o.createOp)==null?void 0:r.map)!=null&&c.entries&&(i.object.createOp.map.entries=this._decodeMapEntries(this.object.createOp.map.entries,t,e)),(l=(d=(p=this.object)==null?void 0:p.createOp)==null?void 0:d.mapOp)!=null&&l.data&&(i.object.createOp.mapOp.data=this._decodeObjectData(this.object.createOp.mapOp.data,t,e)),(g=(h=this.operation)==null?void 0:h.map)!=null&&g.entries&&(i.operation.map.entries=this._decodeMapEntries(this.operation.map.entries,t,e)),(L=(m=this.operation)==null?void 0:m.mapOp)!=null&&L.data&&(i.operation.mapOp.data=this._decodeObjectData(this.operation.mapOp.data,t,e))}catch(D){t.Logger.logAction(t.logger,t.Logger.LOG_ERROR,"WireObjectMessage.decode()",this._utils.inspectError(D))}return i}toJSON(){let t=arguments.length>0?this._utils.Format.json:this._utils.Format.msgpack,s=this.encodeForWire(t),{_utils:e,_messageEncoding:i}=s;return K(s,["_utils","_messageEncoding"])}toString(){return J(this,"WireObjectMessage")}getMessageSize(){var e,i;let t=0;return t+=(i=(e=this.clientId)==null?void 0:e.length)!=null?i:0,this.operation&&(t+=this._getObjectOperationSize(this.operation)),this.object&&(t+=this._getObjectStateSize(this.object)),this.extras&&(t+=JSON.stringify(this.extras).length),t}_getObjectOperationSize(t){let e=0;return t.mapOp&&(e+=this._getMapOpSize(t.mapOp)),t.counterOp&&(e+=this._getCounterOpSize(t.counterOp)),t.map&&(e+=this._getObjectMapSize(t.map)),t.counter&&(e+=this._getObjectCounterSize(t.counter)),e}_getObjectStateSize(t){let e=0;return t.map&&(e+=this._getObjectMapSize(t.map)),t.counter&&(e+=this._getObjectCounterSize(t.counter)),t.createOp&&(e+=this._getObjectOperationSize(t.createOp)),e}_getObjectMapSize(t){var i;let e=0;return Object.entries((i=t.entries)!=null?i:{}).forEach(([n,s])=>{var o;e+=(o=n==null?void 0:n.length)!=null?o:0,s&&(e+=this._getMapEntrySize(s))}),e}_getObjectCounterSize(t){return t.count==null?0:8}_getMapEntrySize(t){let e=0;return t.data&&(e+=this._getObjectDataSize(t.data)),e}_getMapOpSize(t){var i,n;let e=0;return e+=(n=(i=t.key)==null?void 0:i.length)!=null?n:0,t.data&&(e+=this._getObjectDataSize(t.data)),e}_getCounterOpSize(t){return t.amount==null?0:8}_getObjectDataSize(t){let e=0;return t.boolean!=null&&(e+=this._utils.dataSizeBytes(t.boolean)),t.bytes!=null&&(e+=this._utils.dataSizeBytes(t.bytes)),t.number!=null&&(e+=this._utils.dataSizeBytes(t.number)),t.string!=null&&(e+=this._utils.dataSizeBytes(t.string)),t.json!=null&&(e+=this._utils.dataSizeBytes(t.json)),e}_decodeMapEntries(t,e,i){return Object.entries(t).reduce((n,s)=>{let[o,r]=s,c=r.data?this._decodeObjectData(r.data,e,i):void 0;return n[o]=_(O({},r),{data:c}),n},{})}_decodeObjectData(t,e,i){var n,s,o;try{let r;t.bytes!=null&&(r=i==="msgpack"?t.bytes:e.Platform.BufferUtils.base64Decode(String(t.bytes)));let c;return t.json!=null&&(c=JSON.parse(t.json)),{objectId:t.objectId,value:(o=(s=(n=r!=null?r:c)!=null?n:t.boolean)!=null?s:t.number)!=null?o:t.string}}catch(r){return e.Logger.logAction(e.logger,e.Logger.LOG_ERROR,"WireObjectMessage._decodeObjectData()",this._utils.inspectError(r)),O({},t)}}};var j=class{constructor(t,e){this._objects=t;this._client=this._objects.getClient(),this._subscriptions=new this._client.EventEmitter(this._client.logger),this._lifecycleEvents=new this._client.EventEmitter(this._client.logger),this._objectId=e,this._dataRef=this._getZeroValueData(),this._siteTimeserials={},this._createOperationIsMerged=!1,this._tombstone=!1}subscribe(t){return this._objects.throwIfInvalidAccessApiConfiguration(),this._subscriptions.on("updated",t),{unsubscribe:()=>{this._subscriptions.off("updated",t)}}}unsubscribe(t){this._client.Utils.isNil(t)||this._subscriptions.off("updated",t)}unsubscribeAll(){this._subscriptions.off("updated")}on(t,e){return this._lifecycleEvents.on(t,e),{off:()=>{this._lifecycleEvents.off(t,e)}}}off(t,e){this._client.Utils.isNil(t)&&this._client.Utils.isNil(e)||this._lifecycleEvents.off(t,e)}offAll(){this._lifecycleEvents.off()}getObjectId(){return this._objectId}notifyUpdated(t){t.noop||this._subscriptions.emit("updated",t)}tombstone(t){this._tombstone=!0,t.serialTimestamp!=null?this._tombstonedAt=t.serialTimestamp:(this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MINOR,"LiveObject.tombstone()",`object has been tombstoned but no "serialTimestamp" found in the message, using local clock instead; objectId=${this.getObjectId()}`),this._tombstonedAt=Date.now());let e=this.clearData();return e.clientId=t.clientId,e.connectionId=t.connectionId,this._lifecycleEvents.emit("deleted"),e}isTombstoned(){return this._tombstone}tombstonedAt(){return this._tombstonedAt}clearData(){let t=this._dataRef;return this._dataRef=this._getZeroValueData(),this._updateFromDataDiff(t,this._dataRef)}_canApplyOperation(t,e){if(!t)throw new this._client.ErrorInfo(`Invalid serial: ${t}`,92e3,500);if(!e)throw new this._client.ErrorInfo(`Invalid site code: ${e}`,92e3,500);let i=this._siteTimeserials[e];return!i||t>i}_applyObjectDelete(t){return this.tombstone(t)}};var v=class a{constructor(t,e,i){this.type=t;this.hash=e;this.msTimestamp=i}static fromInitialValue(t,e,i,n,s){let o=t.BufferUtils.concat([t.BufferUtils.utf8Encode(i),t.BufferUtils.utf8Encode(":"),t.BufferUtils.utf8Encode(n)]),r=t.BufferUtils.sha256(o),c=t.BufferUtils.base64UrlEncode(r);return new a(e,c,s)}static fromString(t,e){if(t.Utils.isNil(e))throw new t.ErrorInfo("Invalid object id string",92e3,500);let[i,n]=e.split(":");if(!i||!n)throw new t.ErrorInfo("Invalid object id string",92e3,500);if(!["map","counter"].includes(i))throw new t.ErrorInfo(`Invalid object type in object id: ${e}`,92e3,500);let[s,o]=n.split("@");if(!s||!o)throw new t.ErrorInfo("Invalid object id string",92e3,500);if(!Number.isInteger(Number.parseInt(o)))throw new t.ErrorInfo("Invalid object id string",92e3,500);return new a(i,s,Number.parseInt(o))}toString(){return`${this.type}:${this.hash}@${this.msTimestamp}`}};var f=class a extends j{static zeroValue(t,e){return new a(t,e)}static fromObjectState(t,e){let i=new a(t,e.object.objectId);return i.overrideWithObjectState(e),i}static fromObjectOperation(t,e){let i=new a(t,e.operation.objectId);return i._mergeInitialDataFromCreateOperation(e.operation,e),i}static createCounterIncMessage(t,e,i){let n=t.getClient();if(typeof i!="number"||!Number.isFinite(i))throw new n.ErrorInfo("Counter value increment should be a valid number",40003,400);return b.fromValues({operation:{action:4,objectId:e,counterOp:{amount:i}}},n.Utils,n.MessageEncoding)}static async createCounterCreateMessage(t,e){let i=t.getClient();if(e!==void 0&&(typeof e!="number"||!Number.isFinite(e)))throw new i.ErrorInfo("Counter value should be a valid number",40003,400);let n=a.createInitialValueOperation(e),s=x(n,i),o=i.Utils.cheapRandStr(),r=await i.getTimestamp(!0),c=v.fromInitialValue(i.Platform,"counter",s,o,r).toString();return b.fromValues({operation:_(O({},n),{action:3,objectId:c,nonce:o,initialValue:s})},i.Utils,i.MessageEncoding)}static createInitialValueOperation(t){return{counter:{count:t!=null?t:0}}}value(){return this._objects.throwIfInvalidAccessApiConfiguration(),this._dataRef.data}async increment(t){this._objects.throwIfInvalidWriteApiConfiguration();let e=a.createCounterIncMessage(this._objects,this.getObjectId(),t);return this._objects.publish([e])}async decrement(t){if(this._objects.throwIfInvalidWriteApiConfiguration(),typeof t!="number"||!Number.isFinite(t))throw new this._client.ErrorInfo("Counter value decrement should be a valid number",40003,400);return this.increment(-t)}applyOperation(t,e){var o;if(t.objectId!==this.getObjectId())throw new this._client.ErrorInfo(`Cannot apply object operation with objectId=${t.objectId}, to this LiveCounter with objectId=${this.getObjectId()}`,92e3,500);let i=e.serial,n=e.siteCode;if(!this._canApplyOperation(i,n)){this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MICRO,"LiveCounter.applyOperation()",`skipping ${t.action} op: op serial ${i.toString()} <= site serial ${(o=this._siteTimeserials[n])==null?void 0:o.toString()}; objectId=${this.getObjectId()}`);return}if(this._siteTimeserials[n]=i,this.isTombstoned())return;let s;switch(t.action){case 3:s=this._applyCounterCreate(t,e);break;case 4:if(this._client.Utils.isNil(t.counterOp)){this._throwNoPayloadError(t);return}else s=this._applyCounterInc(t.counterOp,e);break;case 5:s=this._applyObjectDelete(e);break;default:throw new this._client.ErrorInfo(`Invalid ${t.action} op for LiveCounter objectId=${this.getObjectId()}`,92e3,500)}this.notifyUpdated(s)}overrideWithObjectState(t){var s,o,r,c,p;let e=t.object;if(e==null)throw new this._client.ErrorInfo(`Missing object state; LiveCounter objectId=${this.getObjectId()}`,92e3,500);if(e.objectId!==this.getObjectId())throw new this._client.ErrorInfo(`Invalid object state: object state objectId=${e.objectId}; LiveCounter objectId=${this.getObjectId()}`,92e3,500);if(!this._client.Utils.isNil(e.createOp)){if(e.createOp.objectId!==this.getObjectId())throw new this._client.ErrorInfo(`Invalid object state: object state createOp objectId=${(s=e.createOp)==null?void 0:s.objectId}; LiveCounter objectId=${this.getObjectId()}`,92e3,500);if(e.createOp.action!==3)throw new this._client.ErrorInfo(`Invalid object state: object state createOp action=${(o=e.createOp)==null?void 0:o.action}; LiveCounter objectId=${this.getObjectId()}`,92e3,500)}if(this._siteTimeserials=(r=e.siteTimeserials)!=null?r:{},this.isTombstoned())return{noop:!0};let i=this._dataRef;e.tombstone?this.tombstone(t):(this._createOperationIsMerged=!1,this._dataRef={data:(p=(c=e.counter)==null?void 0:c.count)!=null?p:0},this._client.Utils.isNil(e.createOp)||this._mergeInitialDataFromCreateOperation(e.createOp,t));let n=this._updateFromDataDiff(i,this._dataRef);return n.clientId=t.clientId,n.connectionId=t.connectionId,n}onGCInterval(){}_getZeroValueData(){return{data:0}}_updateFromDataDiff(t,e){return{update:{amount:e.data-t.data}}}_mergeInitialDataFromCreateOperation(t,e){var i,n,s,o;return this._dataRef.data+=(n=(i=t.counter)==null?void 0:i.count)!=null?n:0,this._createOperationIsMerged=!0,{update:{amount:(o=(s=t.counter)==null?void 0:s.count)!=null?o:0},clientId:e.clientId,connectionId:e.connectionId}}_throwNoPayloadError(t){throw new this._client.ErrorInfo(`No payload found for ${t.action} op for LiveCounter objectId=${this.getObjectId()}`,92e3,500)}_applyCounterCreate(t,e){return this._createOperationIsMerged?(this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MICRO,"LiveCounter._applyCounterCreate()",`skipping applying COUNTER_CREATE op on a counter instance as it was already applied before; objectId=${this.getObjectId()}`),{noop:!0}):this._mergeInitialDataFromCreateOperation(t,e)}_applyCounterInc(t,e){return this._dataRef.data+=t.amount,{update:{amount:t.amount},clientId:e.clientId,connectionId:e.connectionId}}};var S=class{constructor(t,e,i){this._batchContext=t;this._objects=e;this._counter=i;this._client=this._objects.getClient()}value(){return this._objects.throwIfInvalidAccessApiConfiguration(),this._batchContext.throwIfClosed(),this._counter.value()}increment(t){this._objects.throwIfInvalidWriteApiConfiguration(),this._batchContext.throwIfClosed();let e=f.createCounterIncMessage(this._objects,this._counter.getObjectId(),t);this._batchContext.queueMessage(e)}decrement(t){if(this._objects.throwIfInvalidWriteApiConfiguration(),this._batchContext.throwIfClosed(),typeof t!="number")throw new this._client.ErrorInfo("Counter value decrement should be a number",40003,400);this.increment(-t)}};var Z=Object.prototype.hasOwnProperty;function Y(a,t,e){for(e of a.keys())if(I(e,t))return e}function I(a,t){var e,i,n;if(a===t)return!0;if(a&&t&&(e=a.constructor)===t.constructor){if(e===Date)return a.getTime()===t.getTime();if(e===RegExp)return a.toString()===t.toString();if(e===Array){if((i=a.length)===t.length)for(;i--&&I(a[i],t[i]););return i===-1}if(e===Set){if(a.size!==t.size)return!1;for(i of a)if(n=i,n&&typeof n=="object"&&(n=Y(t,n),!n)||!t.has(n))return!1;return!0}if(e===Map){if(a.size!==t.size)return!1;for(i of a)if(n=i[0],n&&typeof n=="object"&&(n=Y(t,n),!n)||!I(i[1],t.get(n)))return!1;return!0}if(e===ArrayBuffer)a=new Uint8Array(a),t=new Uint8Array(t);else if(e===DataView){if((i=a.byteLength)===t.byteLength)for(;i--&&a.getInt8(i)===t.getInt8(i););return i===-1}if(ArrayBuffer.isView(a)){if((i=a.byteLength)===t.byteLength)for(;i--&&a[i]===t[i];);return i===-1}if(!e||typeof a=="object"){i=0;for(e in a)if(Z.call(a,e)&&++i&&!Z.call(t,e)||!(e in t)||!I(a[e],t[e]))return!1;return Object.keys(t).length===i}}return a!==a&&t!==t}var u=class a extends j{constructor(e,i,n){super(e,n);this._semantics=i}static zeroValue(e,i){return new a(e,0,i)}static fromObjectState(e,i){let n=new a(e,i.object.map.semantics,i.object.objectId);return n.overrideWithObjectState(i),n}static fromObjectOperation(e,i){var s;let n=new a(e,(s=i.operation.map)==null?void 0:s.semantics,i.operation.objectId);return n._mergeInitialDataFromCreateOperation(i.operation,i),n}static createMapSetMessage(e,i,n,s){let o=e.getClient();a.validateKeyValue(e,n,s);let r;return s instanceof j?r={objectId:s.getObjectId()}:r={value:s},b.fromValues({operation:{action:1,objectId:i,mapOp:{key:n,data:r}}},o.Utils,o.MessageEncoding)}static createMapRemoveMessage(e,i,n){let s=e.getClient();if(typeof n!="string")throw new s.ErrorInfo("Map key should be string",40003,400);return b.fromValues({operation:{action:2,objectId:i,mapOp:{key:n}}},s.Utils,s.MessageEncoding)}static validateKeyValue(e,i,n){let s=e.getClient();if(typeof i!="string")throw new s.ErrorInfo("Map key should be string",40003,400);if(n===null||typeof n!="string"&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="object")throw new s.ErrorInfo("Map value data type is unsupported",40013,400)}static async createMapCreateMessage(e,i){let n=e.getClient();if(i!==void 0&&(i===null||typeof i!="object"))throw new n.ErrorInfo("Map entries should be a key-value object",40003,400);Object.entries(i!=null?i:{}).forEach(([l,h])=>a.validateKeyValue(e,l,h));let s=a.createInitialValueOperation(i),o=x(s,n),r=n.Utils.cheapRandStr(),c=await n.getTimestamp(!0),p=v.fromInitialValue(n.Platform,"map",o,r,c).toString();return b.fromValues({operation:_(O({},s),{action:0,objectId:p,nonce:r,initialValue:o})},n.Utils,n.MessageEncoding)}static createInitialValueOperation(e){let i={};return Object.entries(e!=null?e:{}).forEach(([n,s])=>{let o;s instanceof j?o={objectId:s.getObjectId()}:o={value:s},i[n]={data:o}}),{map:{semantics:0,entries:i}}}get(e){if(this._objects.throwIfInvalidAccessApiConfiguration(),this.isTombstoned())return;let i=this._dataRef.data.get(e);if(i!==void 0&&i.tombstone!==!0)return this._getResolvedValueFromObjectData(i.data)}size(){this._objects.throwIfInvalidAccessApiConfiguration();let e=0;for(let i of this._dataRef.data.values())this._isMapEntryTombstoned(i)||e++;return e}*entries(){this._objects.throwIfInvalidAccessApiConfiguration();for(let[e,i]of this._dataRef.data.entries()){if(this._isMapEntryTombstoned(i))continue;let n=this._getResolvedValueFromObjectData(i.data);yield[e,n]}}*keys(){for(let[e]of this.entries())yield e}*values(){for(let[e,i]of this.entries())yield i}async set(e,i){this._objects.throwIfInvalidWriteApiConfiguration();let n=a.createMapSetMessage(this._objects,this.getObjectId(),e,i);return this._objects.publish([n])}async remove(e){this._objects.throwIfInvalidWriteApiConfiguration();let i=a.createMapRemoveMessage(this._objects,this.getObjectId(),e);return this._objects.publish([i])}applyOperation(e,i){var r;if(e.objectId!==this.getObjectId())throw new this._client.ErrorInfo(`Cannot apply object operation with objectId=${e.objectId}, to this LiveMap with objectId=${this.getObjectId()}`,92e3,500);let n=i.serial,s=i.siteCode;if(!this._canApplyOperation(n,s)){this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MICRO,"LiveMap.applyOperation()",`skipping ${e.action} op: op serial ${n.toString()} <= site serial ${(r=this._siteTimeserials[s])==null?void 0:r.toString()}; objectId=${this.getObjectId()}`);return}if(this._siteTimeserials[s]=n,this.isTombstoned())return;let o;switch(e.action){case 0:o=this._applyMapCreate(e,i);break;case 1:if(this._client.Utils.isNil(e.mapOp)){this._throwNoPayloadError(e);return}else o=this._applyMapSet(e.mapOp,n,i);break;case 2:if(this._client.Utils.isNil(e.mapOp)){this._throwNoPayloadError(e);return}else o=this._applyMapRemove(e.mapOp,n,i.serialTimestamp,i);break;case 5:o=this._applyObjectDelete(i);break;default:throw new this._client.ErrorInfo(`Invalid ${e.action} op for LiveMap objectId=${this.getObjectId()}`,92e3,500)}this.notifyUpdated(o)}overrideWithObjectState(e){var o,r,c,p,d,l,h,g,m;let i=e.object;if(i==null)throw new this._client.ErrorInfo(`Missing object state; LiveMap objectId=${this.getObjectId()}`,92e3,500);if(i.objectId!==this.getObjectId())throw new this._client.ErrorInfo(`Invalid object state: object state objectId=${i.objectId}; LiveMap objectId=${this.getObjectId()}`,92e3,500);if(((o=i.map)==null?void 0:o.semantics)!==this._semantics)throw new this._client.ErrorInfo(`Invalid object state: object state map semantics=${(r=i.map)==null?void 0:r.semantics}; LiveMap semantics=${this._semantics}`,92e3,500);if(!this._client.Utils.isNil(i.createOp)){if(i.createOp.objectId!==this.getObjectId())throw new this._client.ErrorInfo(`Invalid object state: object state createOp objectId=${(c=i.createOp)==null?void 0:c.objectId}; LiveMap objectId=${this.getObjectId()}`,92e3,500);if(i.createOp.action!==0)throw new this._client.ErrorInfo(`Invalid object state: object state createOp action=${(p=i.createOp)==null?void 0:p.action}; LiveMap objectId=${this.getObjectId()}`,92e3,500);if(((d=i.createOp.map)==null?void 0:d.semantics)!==this._semantics)throw new this._client.ErrorInfo(`Invalid object state: object state createOp map semantics=${(l=i.createOp.map)==null?void 0:l.semantics}; LiveMap semantics=${this._semantics}`,92e3,500)}if(this._siteTimeserials=(h=i.siteTimeserials)!=null?h:{},this.isTombstoned())return{noop:!0};let n=this._dataRef;i.tombstone?this.tombstone(e):(this._createOperationIsMerged=!1,this._dataRef=this._liveMapDataFromMapEntries((m=(g=i.map)==null?void 0:g.entries)!=null?m:{}),this._client.Utils.isNil(i.createOp)||this._mergeInitialDataFromCreateOperation(i.createOp,e));let s=this._updateFromDataDiff(n,this._dataRef);return s.clientId=e.clientId,s.connectionId=e.connectionId,s}onGCInterval(){let e=[];for(let[i,n]of this._dataRef.data.entries())n.tombstone===!0&&Date.now()-n.tombstonedAt>=this._objects.gcGracePeriod&&e.push(i);e.forEach(i=>this._dataRef.data.delete(i))}_getZeroValueData(){return{data:new Map}}_updateFromDataDiff(e,i){let n={update:{}};for(let[s,o]of e.data.entries()){let r=s;o.tombstone===!1&&!i.data.has(r)&&(n.update[r]="removed")}for(let[s,o]of i.data.entries()){let r=s;if(!e.data.has(r)){if(o.tombstone===!1){n.update[r]="updated";continue}if(o.tombstone===!0)continue}let c=e.data.get(r);if(c.tombstone===!0&&o.tombstone===!1){n.update[r]="updated";continue}if(c.tombstone===!1&&o.tombstone===!0){n.update[r]="removed";continue}if(c.tombstone===!0&&o.tombstone===!0)continue;if(!I(c.data,o.data)){n.update[r]="updated";continue}}return n}_mergeInitialDataFromCreateOperation(e,i){var s;if(this._client.Utils.isNil(e.map))return{update:{},clientId:i.clientId,connectionId:i.connectionId};let n={update:{},clientId:i.clientId,connectionId:i.connectionId};return Object.entries((s=e.map.entries)!=null?s:{}).forEach(([o,r])=>{let c=r.timeserial,p;r.tombstone===!0?p=this._applyMapRemove({key:o},c,r.serialTimestamp,i):p=this._applyMapSet({key:o,data:r.data},c,i),!p.noop&&Object.assign(n.update,p.update)}),this._createOperationIsMerged=!0,n}_throwNoPayloadError(e){throw new this._client.ErrorInfo(`No payload found for ${e.action} op for LiveMap objectId=${this.getObjectId()}`,92e3,500)}_applyMapCreate(e,i){var n,s;if(this._createOperationIsMerged)return this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MICRO,"LiveMap._applyMapCreate()",`skipping applying MAP_CREATE op on a map instance as it was already applied before; objectId=${this.getObjectId()}`),{noop:!0};if(this._semantics!==((n=e.map)==null?void 0:n.semantics))throw new this._client.ErrorInfo(`Cannot apply MAP_CREATE op on LiveMap objectId=${this.getObjectId()}; map's semantics=${this._semantics}, but op expected ${(s=e.map)==null?void 0:s.semantics}`,92e3,500);return this._mergeInitialDataFromCreateOperation(e,i)}_applyMapSet(e,i,n){var l;let{ErrorInfo:s,Utils:o}=this._client,r=this._dataRef.data.get(e.key);if(r&&!this._canApplyMapOperation(r.timeserial,i))return this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MICRO,"LiveMap._applyMapSet()",`skipping update for key="${e.key}": op serial ${i==null?void 0:i.toString()} <= entry serial ${(l=r.timeserial)==null?void 0:l.toString()}; objectId=${this.getObjectId()}`),{noop:!0};if(o.isNil(e.data)||o.isNil(e.data.objectId)&&o.isNil(e.data.value))throw new s(`Invalid object data for MAP_SET op on objectId=${this.getObjectId()} on key="${e.key}"`,92e3,500);let c;if(o.isNil(e.data.objectId)?c={value:e.data.value}:(c={objectId:e.data.objectId},this._objects.getPool().createZeroValueObjectIfNotExists(e.data.objectId)),r)r.tombstone=!1,r.tombstonedAt=void 0,r.timeserial=i,r.data=c;else{let h={tombstone:!1,tombstonedAt:void 0,timeserial:i,data:c};this._dataRef.data.set(e.key,h)}let p={update:{},clientId:n.clientId,connectionId:n.connectionId},d=e.key;return p.update[d]="updated",p}_applyMapRemove(e,i,n,s){var d;let o=this._dataRef.data.get(e.key);if(o&&!this._canApplyMapOperation(o.timeserial,i))return this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MICRO,"LiveMap._applyMapRemove()",`skipping remove for key="${e.key}": op serial ${i==null?void 0:i.toString()} <= entry serial ${(d=o.timeserial)==null?void 0:d.toString()}; objectId=${this.getObjectId()}`),{noop:!0};let r;if(n!=null?r=n:(this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MINOR,"LiveMap._applyMapRemove()",`map key has been removed but no "serialTimestamp" found in the message, using local clock instead; key="${e.key}", objectId=${this.getObjectId()}`),r=Date.now()),o)o.tombstone=!0,o.tombstonedAt=r,o.timeserial=i,o.data=void 0;else{let l={tombstone:!0,tombstonedAt:r,timeserial:i,data:void 0};this._dataRef.data.set(e.key,l)}let c={update:{},clientId:s.clientId,connectionId:s.connectionId},p=e.key;return c.update[p]="removed",c}_canApplyMapOperation(e,i){return!e&&!i?!1:e?i?i>e:!1:!0}_liveMapDataFromMapEntries(e){let i={data:new Map};return Object.entries(e!=null?e:{}).forEach(([n,s])=>{let o;this._client.Utils.isNil(s.data)||(this._client.Utils.isNil(s.data.objectId)?o={value:s.data.value}:o={objectId:s.data.objectId});let r;s.tombstone===!0&&(s.serialTimestamp!=null?r=s.serialTimestamp:(this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MINOR,"LiveMap._liveMapDataFromMapEntries()",`map key is removed but no "serialTimestamp" found, using local clock instead; key="${n}", objectId=${this.getObjectId()}`),r=Date.now()));let c={timeserial:s.timeserial,data:o,tombstone:s.tombstone===!0,tombstonedAt:r};i.data.set(n,c)}),i}_getResolvedValueFromObjectData(e){let i=e.value;if(i!=null)return i;let n=e.objectId,s=this._objects.getPool().get(n);if(s&&!s.isTombstoned())return s}_isMapEntryTombstoned(e){if(e.tombstone===!0)return!0;let i=e.data;if("objectId"in i){let n=this._objects.getPool().get(i.objectId);if(n!=null&&n.isTombstoned())return!0}return!1}};var T=class{constructor(t,e,i){this._batchContext=t;this._objects=e;this._map=i}get(t){this._objects.throwIfInvalidAccessApiConfiguration(),this._batchContext.throwIfClosed();let e=this._map.get(t);return e instanceof j?this._batchContext.getWrappedObject(e.getObjectId()):e}size(){return this._objects.throwIfInvalidAccessApiConfiguration(),this._batchContext.throwIfClosed(),this._map.size()}*entries(){this._objects.throwIfInvalidAccessApiConfiguration(),this._batchContext.throwIfClosed(),yield*P(this._map.entries())}*keys(){this._objects.throwIfInvalidAccessApiConfiguration(),this._batchContext.throwIfClosed(),yield*P(this._map.keys())}*values(){this._objects.throwIfInvalidAccessApiConfiguration(),this._batchContext.throwIfClosed(),yield*P(this._map.values())}set(t,e){this._objects.throwIfInvalidWriteApiConfiguration(),this._batchContext.throwIfClosed();let i=u.createMapSetMessage(this._objects,this._map.getObjectId(),t,e);this._batchContext.queueMessage(i)}remove(t){this._objects.throwIfInvalidWriteApiConfiguration(),this._batchContext.throwIfClosed();let e=u.createMapRemoveMessage(this._objects,this._map.getObjectId(),t);this._batchContext.queueMessage(e)}};var M={gcInterval:3e5,gcGracePeriod:864e5};var E="root",U=class{constructor(t){this._objects=t;var e,i;this._client=this._objects.getClient(),this._pool=this._createInitialPool(),this._gcInterval=setInterval(()=>{this._onGCInterval()},M.gcInterval),(i=(e=this._gcInterval).unref)==null||i.call(e)}get(t){return this._pool.get(t)}deleteExtraObjectIds(t){[...this._pool.keys()].filter(n=>!t.includes(n)).forEach(n=>this._pool.delete(n))}set(t,e){this._pool.set(t,e)}resetToInitialPool(t){let e=this._pool.get(E);this._pool.clear(),this._pool.set(e.getObjectId(),e),this.clearObjectsData(t)}clearObjectsData(t){for(let e of this._pool.values()){let i=e.clearData();t&&e.notifyUpdated(i)}}createZeroValueObjectIfNotExists(t){let e=this.get(t);if(e)return e;let i=v.fromString(this._client,t),n;switch(i.type){case"map":{n=u.zeroValue(this._objects,t);break}case"counter":n=f.zeroValue(this._objects,t);break}return this.set(t,n),n}_createInitialPool(){let t=new Map,e=u.zeroValue(this._objects,E);return t.set(e.getObjectId(),e),t}_onGCInterval(){let t=[];for(let[e,i]of this._pool.entries()){if(i.isTombstoned()&&Date.now()-i.tombstonedAt()>=this._objects.gcGracePeriod){t.push(e);continue}i.onGCInterval()}t.forEach(e=>this._pool.delete(e))}};var R=class{constructor(t,e){this._objects=t;this._root=e;this._wrappedObjects=new Map;this._queuedMessages=[];this._isClosed=!1;this._client=t.getClient(),this._wrappedObjects.set(this._root.getObjectId(),new T(this,this._objects,this._root))}getRoot(){return this._objects.throwIfInvalidAccessApiConfiguration(),this.throwIfClosed(),this.getWrappedObject(E)}getWrappedObject(t){if(this._wrappedObjects.has(t))return this._wrappedObjects.get(t);let e=this._objects.getPool().get(t);if(!e)return;let i;if(e instanceof u)i=new T(this,this._objects,e);else if(e instanceof f)i=new S(this,this._objects,e);else throw new this._client.ErrorInfo(`Unknown LiveObject instance type: objectId=${e.getObjectId()}`,5e4,500);return this._wrappedObjects.set(t,i),i}throwIfClosed(){if(this.isClosed())throw new this._client.ErrorInfo("Batch is closed",4e4,400)}isClosed(){return this._isClosed}close(){this._isClosed=!0}queueMessage(t){this._queuedMessages.push(t)}async flush(){try{this.close(),this._queuedMessages.length>0&&await this._objects.publish(this._queuedMessages)}finally{this._wrappedObjects.clear(),this._queuedMessages=[]}}};var N=class{constructor(t){this._objects=t;this._client=this._objects.getClient(),this._channel=this._objects.getChannel(),this._pool=new Map}entries(){return this._pool.entries()}size(){return this._pool.size}isEmpty(){return this._pool.size===0}clear(){this._pool.clear()}applyObjectSyncMessages(t){for(let e of t){if(!e.object){this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MAJOR,"SyncObjectsDataPool.applyObjectSyncMessages()",`object message is received during OBJECT_SYNC without 'object' field, skipping message; message id: ${e.id}, channel: ${this._channel.name}`);continue}let i=e.object;i.counter?this._pool.set(i.objectId,this._createLiveCounterDataEntry(e)):i.map?this._pool.set(i.objectId,this._createLiveMapDataEntry(e)):this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MAJOR,"SyncObjectsDataPool.applyObjectSyncMessages()",`received unsupported object state message during OBJECT_SYNC, expected 'counter' or 'map' to be present, skipping message; message id: ${e.id}, channel: ${this._channel.name}`)}}_createLiveCounterDataEntry(t){return{objectMessage:t,objectType:"LiveCounter"}}_createLiveMapDataEntry(t){return{objectMessage:t,objectType:"LiveMap"}}};var se={initialized:void 0,syncing:"syncing",synced:"synced"},C=class{constructor(t){var e,i;this._channel=t,this._client=t.client,this._state="initialized",this._eventEmitterInternal=new this._client.EventEmitter(this._client.logger),this._eventEmitterPublic=new this._client.EventEmitter(this._client.logger),this._objectsPool=new U(this),this._syncObjectsDataPool=new N(this),this._bufferedObjectOperations=[],this.gcGracePeriod=(i=(e=this._channel.connectionManager.connectionDetails)==null?void 0:e.objectsGCGracePeriod)!=null?i:M.gcGracePeriod,this._channel.connectionManager.on("connectiondetails",n=>{var s;this.gcGracePeriod=(s=n.objectsGCGracePeriod)!=null?s:M.gcGracePeriod})}async getRoot(){return this.throwIfInvalidAccessApiConfiguration(),this._state!=="synced"&&await this._eventEmitterInternal.once("synced"),this._objectsPool.get(E)}async batch(t){this.throwIfInvalidWriteApiConfiguration();let e=await this.getRoot(),i=new R(this,e);try{t(i),await i.flush()}finally{i.close()}}async createMap(t){var s;this.throwIfInvalidWriteApiConfiguration();let e=await u.createMapCreateMessage(this,t),i=(s=e.operation)==null?void 0:s.objectId;if(await this.publish([e]),this._objectsPool.get(i))return this._objectsPool.get(i);let n=u.fromObjectOperation(this,e);return this._objectsPool.set(i,n),n}async createCounter(t){var s;this.throwIfInvalidWriteApiConfiguration();let e=await f.createCounterCreateMessage(this,t),i=(s=e.operation)==null?void 0:s.objectId;if(await this.publish([e]),this._objectsPool.get(i))return this._objectsPool.get(i);let n=f.fromObjectOperation(this,e);return this._objectsPool.set(i,n),n}on(t,e){return this._eventEmitterPublic.on(t,e),{off:()=>{this._eventEmitterPublic.off(t,e)}}}off(t,e){this._client.Utils.isNil(t)&&this._client.Utils.isNil(e)||this._eventEmitterPublic.off(t,e)}offAll(){this._eventEmitterPublic.off()}getPool(){return this._objectsPool}getChannel(){return this._channel}getClient(){return this._client}handleObjectSyncMessages(t,e){let{syncId:i,syncCursor:n}=this._parseSyncChannelSerial(e),s=this._currentSyncId!==i;s&&this._startNewSync(i,n),this._syncObjectsDataPool.applyObjectSyncMessages(t),n||this._endSync(s)}handleObjectMessages(t){if(this._state!=="synced"){this._bufferedObjectOperations.push(...t);return}this._applyObjectMessages(t)}onAttached(t){this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MINOR,"Objects.onAttached()",`channel=${this._channel.name}, hasObjects=${t}`);let e=this._state==="initialized";(t||e)&&this._startNewSync(),t||(this._objectsPool.resetToInitialPool(!0),this._syncObjectsDataPool.clear(),this._endSync(e))}actOnChannelState(t,e){switch(t){case"attached":this.onAttached(e);break;case"detached":case"failed":this._objectsPool.clearObjectsData(!1),this._syncObjectsDataPool.clear();break}}async publish(t){this._channel.throwIfUnpublishableState();let e=t.map(s=>s.encode(this._client)),i=this._client.options.maxMessageSize,n=e.reduce((s,o)=>s+o.getMessageSize(),0);if(n>i)throw new this._client.ErrorInfo(`Maximum size of object messages that can be published at once exceeded (was ${n} bytes; limit is ${i} bytes)`,40009,400);return this._channel.sendState(e)}throwIfInvalidAccessApiConfiguration(){this._throwIfMissingChannelMode("object_subscribe"),this._throwIfInChannelState(["detached","failed"])}throwIfInvalidWriteApiConfiguration(){this._throwIfMissingChannelMode("object_publish"),this._throwIfInChannelState(["detached","failed","suspended"]),this._throwIfEchoMessagesDisabled()}_startNewSync(t,e){this._bufferedObjectOperations=[],this._syncObjectsDataPool.clear(),this._currentSyncId=t,this._currentSyncCursor=e,this._stateChange("syncing",!1)}_endSync(t){this._applySync(),this._applyObjectMessages(this._bufferedObjectOperations),this._bufferedObjectOperations=[],this._syncObjectsDataPool.clear(),this._currentSyncId=void 0,this._currentSyncCursor=void 0,this._stateChange("synced",t)}_parseSyncChannelSerial(t){let e,i,n;return t&&(e=t.match(/^([\w-]+):(.*)$/))&&(i=e[1],n=e[2]),{syncId:i,syncCursor:n}}_applySync(){if(this._syncObjectsDataPool.isEmpty())return;let t=new Set,e=[];for(let[i,n]of this._syncObjectsDataPool.entries()){t.add(i);let s=this._objectsPool.get(i);if(s){let c=s.overrideWithObjectState(n.objectMessage);e.push({object:s,update:c});continue}let o,r=n.objectType;switch(r){case"LiveCounter":o=f.fromObjectState(this,n.objectMessage);break;case"LiveMap":o=u.fromObjectState(this,n.objectMessage);break;default:throw new this._client.ErrorInfo(`Unknown LiveObject type: ${r}`,5e4,500)}this._objectsPool.set(i,o)}this._objectsPool.deleteExtraObjectIds([...t]),e.forEach(({object:i,update:n})=>i.notifyUpdated(n))}_applyObjectMessages(t){for(let e of t){if(!e.operation){this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MAJOR,"Objects._applyObjectMessages()",`object operation message is received without 'operation' field, skipping message; message id: ${e.id}, channel: ${this._channel.name}`);continue}let i=e.operation;switch(i.action){case 0:case 3:case 1:case 2:case 4:case 5:this._objectsPool.createZeroValueObjectIfNotExists(i.objectId),this._objectsPool.get(i.objectId).applyOperation(i,e);break;default:this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MAJOR,"Objects._applyObjectMessages()",`received unsupported action in object operation message: ${i.action}, skipping message; message id: ${e.id}, channel: ${this._channel.name}`)}}}_throwIfMissingChannelMode(t){var e;if(this._channel.modes!=null&&!this._channel.modes.includes(t))throw new this._client.ErrorInfo(`"${t}" channel mode must be set for this operation`,40024,400);if(!this._client.Utils.allToLowerCase((e=this._channel.channelOptions.modes)!=null?e:[]).includes(t))throw new this._client.ErrorInfo(`"${t}" channel mode must be set for this operation`,40024,400)}_stateChange(t,e){if(this._state===t)return;this._state=t;let i=se[t];i&&(e?this._client.Platform.Config.nextTick(()=>{this._eventEmitterInternal.emit(i),this._eventEmitterPublic.emit(i)}):(this._eventEmitterInternal.emit(i),this._eventEmitterPublic.emit(i)))}_throwIfInChannelState(t){if(t.includes(this._channel.state))throw this._client.ErrorInfo.fromValues(this._channel.invalidStateError())}_throwIfEchoMessagesDisabled(){if(this._channel.client.options.echoMessages===!1)throw new this._channel.client.ErrorInfo('"echoMessages" client option must be enabled for this operation',4e4,400)}};C._DEFAULTS=M;var oe={Objects:C,ObjectMessage:b,WireObjectMessage:y};
if (typeof module.exports == "object" && typeof exports == "object") {
  var __cp = (to, from, except, desc) => {
    if ((from && typeof from === "object") || typeof from === "function") {
      for (let key of Object.getOwnPropertyNames(from)) {
        if (!Object.prototype.hasOwnProperty.call(to, key) && key !== except)
        Object.defineProperty(to, key, {
          get: () => from[key],
          enumerable: !(desc = Object.getOwnPropertyDescriptor(from, key)) || desc.enumerable,
        });
      }
    }
    return to;
  };
  module.exports = __cp(module.exports, exports);
}
return module.exports;
}))
//# sourceMappingURL=objects.umd.min.js.map
